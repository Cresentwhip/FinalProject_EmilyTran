let dad, kid;
let Children = [];
let Vertical = [];
let Horizontal = [];
let Patrol = [];
let sideboundary, verticalboundary;
let xdirection = 1;
let ydirection = 1;
let maze;

//STARTING COMPONENTS
let levelmaze = 1; //start at 1
let kidcount = 0; //start with 0 kids picked up
let success = false;

//GOALS
let totalKids = 15; //max kids to pick up
let lastmaze = 3;

function preload() {

}

function setup() {

	background('gray');
	createCanvas(windowWidth, windowHeight);
	frameRate(120);


	//maze setup
	sideboundary = width - 50 -width/4; //prevents stuckage
	verticalboundary = height - height/10;
	
	



	//movement assignment
	for (let i = 0; i < totalKids; i++) { //create  kids on the screen per level
		Children.push(new Kid(random(sideboundary), random(verticalboundary), 25));
		Children[i].choice = int(random(1, 4)); //asign movement beforehand

		if (Children[i].choice == 1) {
			Vertical.push(Children[i]);
		} else if (Children[i].choice == 2) {
			Horizontal.push(Children[i]);
		} else {
			Patrol.push(Children[i]);
		}

		dad = new Father(0, 0, 25, 100);
	}

}


function draw() {

	//Drawing
	background('gray');
	dad.display();
	makesprites();

	

	//Dad movement
	if (keyIsDown(LEFT_ARROW)) {
		dad.x -= 5;
	}
	if (keyIsDown(RIGHT_ARROW)) {
		dad.x += 5;
	}
	if (keyIsDown(UP_ARROW)) {
		dad.y -= 5;
	} else if (keyIsDown(DOWN_ARROW)) {
		dad.y += 5;
	}


	//children movement
	for (let i = 0; i < Children.length; i++) {
		Children[i].display();
	}
	for (let i = 0; i < Horizontal.length; i++) {
		Horizontal[i].bouncesidemove();
	}
	for (let i = 0; i < Vertical.length; i++) {
		Vertical[i].bounceverticalmove();
	}
	for (let i = 0; i < Patrol.length; i++) {
		Patrol[i].patrollermove();
	}
	
	//BOTTOM SCOREBOARD
	//catchpen 
	fill(255);
	stroke('black');
	strokeWeight(5);
	catcherPen = rect(width-(width/4), height-(height/10), width/4-5,height/10-5);
	
	//caught


}

class Father {
	constructor(x, y, h, w) {
		this.x = random(x); //random location
		this.y = random(y);
		this.height = h;
		this.width = w;

		this.r = int(random(255));
		this.g = int(random(255));
		this.b = int(random(255));
		this.skin = color(this.r, this.g, this.b);
	}

	display() {
		fill(this.skin);
		rect(this.x, this.y, this.height, this.width);
	}

	hiding() {
		//if collide with spot, sprite changes, and if kid is on it, capture=true
	}

	hit(player) {
		if (Math.abs(this.position.x - player.position.x) < this.size / 2 + player.size / 2 && Math.abs(this.position.y - player.position.y) < this.size / 2 + player.size / 2) return true;
	}


}


class Kid {
	constructor(xx, yy, size) {
		this.x = xx;
		this.y = yy;
		this.size = size;

		this.r = int(random(255));
		this.g = int(random(255));
		this.b = int(random(255));
		this.skin = color(this.r, this.g, this.b);
	}

	display() {
		fill(this.skin);
		square(this.x, this.y, this.size);

	}

	bouncesidemove() {
		this.x = this.x + ((1) * xdirection); //reversal of direction when touch wall
		if (this.x > width - this.size || this.x < 0) {
			xdirection *= -1;
		}
	}

	bounceverticalmove() {
		this.y = this.y + ((1) * ydirection); //reversal of direction when touch wall
		if (this.y > height - this.size-100 || this.y < 0) {
			ydirection *= -1;
		}
	}

	patrollermove() {
		if (this.x <= width) {
			this.x++;
		} else {
			this.x = 0
		}
	}
}
function makesprites() {
	kidsprites = new Group();

}

function allkidscaught() {
	switch (maze) {
		case 1:
			if (count == LevelOneKids.length) {}
			break;
case 2:
			if (count == LevelTwoKids.length) {}
			break;

case 3:
			if (count == LevelThreeKids.length) {}
			break;
	}
}


